<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"Client.js.html":{"id":"Client.js.html","title":"Source: Client.js","body":" Gekkou Classes ClientMessageRoomUser Events Client#event:disconnectClient#event:loginClient#event:readyClient#event:roomDisconnectClient#event:roomReadyRoom#event:ready Source: Client.js const RoomManager = require(&quot;./rooming/RoomManager&quot;); var EventEmitter; try { EventEmitter = require(&quot;eventemitter3&quot;); } catch (error) { EventEmitter = require(&quot;events&quot;).EventEmitter; } /** * Represents a Gekkou client * @prop {String} username The client username * @prop {String} password The client password * @prop {String} site The client wiki domain * @prop {Number} startTime Timestamp of bot ready event * @prop {Number} uptime How long in milliseconds the client has been up for */ class Client extends EventEmitter { /** * Create a client * @arg {String} username Client username * @arg {String} password Client password * @arg {Object} [options] Gekkou options (optional) * @arg {Boolean} [options.autoreconnect=true] Have Gekkou autoreconnect when connection is lost * @arg {Boolean} [options.forcehttp=false] Disable HTTPS and force connecting to chat over HTTP. Only enable if you have problems connecting over HTTPS. * @arg {Number} [options.defaultImageSize=150] The default size to return user avatars or anything else. Can be whatever you want. */ constructor(username, password, options = {}) { super(); if (!(username || password)) { throw new Error(&quot;No username or password specified&quot;); } this.options = { &quot;autoreconnect&quot;: true, &quot;forcehttp&quot;: false, &quot;defaultImageSize&quot;: 150 }; if (typeof options === &quot;object&quot;) { for (const item in options) { this.options[item] = options[item]; } } this.username = username; this.password = password; this.request = require(&quot;./rest/RequestHandler&quot;); this.rooms = new RoomManager(this); this.userCount = 0; } get uptime() { return this.startTime ? Date.now() - this.startTime : 0; } /** * Tell the client to connect all rooms. * The arguments passed will be taken as sites to connect the bot * @param {String} sites The site to connect * @returns {Promise} Resolves when the client are connected */ connect(...sites) { // eslint-disable-line no-unused-vars return new Promise((resolve, reject) =&gt; { this.login().then(() =&gt; { if (arguments.length === 0) { reject(&quot;No site specified&quot;); } this.site = Array.from(arguments); for (const site of this.site) { if (typeof site === &quot;string&quot;) { this.rooms.spawn(site); } else if (Array.isArray(site)) { for (let _site of site) { if (typeof _site === &quot;string&quot;) { this.rooms.spawn(_site); } } } else if (typeof site === &quot;function&quot;) { let _site = site(); if (_site &amp;&amp; typeof _site === &quot;string&quot;) { this.rooms.spawn(_site); } } } this.rooms.connect(); resolve(); }); }); } login() { return new Promise((resolve, reject) =&gt; { if (!this.loggedIn) { this.request(&quot;POST&quot;, &quot;https://services.wikia.com/auth/token&quot;, { &quot;username&quot;: this.username, &quot;password&quot;: this.password }).then(() =&gt; { this.loggedIn = true; /** * Fired when the user is logged * @event Client#login */ this.emit(&quot;login&quot;); resolve(); }).catch(reject); } else { resolve(); } }); } disconnect() { this.ready = false; this.rooms.forEach((room) =&gt; { room.disconnect(); }); this.rooms.connectQueue = []; } /** * Create a message * @arg {String} room A room ID or name to send the message * @arg {String} content A content string */ createMessage(room, content) { return this.rooms.createMessage.call(this.rooms, room, content); } /** * Update the bot's status in all rooms * @param {String} status Sets the bot's status, either `here` or `away` */ editStatus(status) { return this.rooms.editStatus.call(this.rooms, status); } } module.exports = Client; × Search results Close "},"rooming_RoomManager.js.html":{"id":"rooming_RoomManager.js.html","title":"Source: rooming/RoomManager.js","body":" Gekkou Classes ClientMessageRoomUser Events Client#event:disconnectClient#event:loginClient#event:readyClient#event:roomDisconnectClient#event:roomReadyRoom#event:ready Source: rooming/RoomManager.js const Collection = require(&quot;../util/Collection&quot;); const Room = require(&quot;../structures/Room&quot;); class RoomManager extends Collection { constructor(client) { super(Room); this._client = client; this.connectQueue = []; } connect() { for (var site of this.connectQueue) { var room = this.get(site); if (!room) { room = this.add(new Room(site, this._client)); } if (room.status === &quot;ready&quot;) return; room.connect(); room.on(&quot;ready&quot;, () =&gt; { /** * Fired when a room turns ready * @event Client#roomReady * @prop {Number} id the ID of the room */ this._client.emit(&quot;roomReady&quot;, room.id); if (this._client.ready) { return; } for (var other of this) { if (!other[1].ready) { return; } } this._client.ready = true; this._client.startTime = Date.now(); /** * Fired when all rooms turn ready * @event Client#ready */ this._client.emit(&quot;ready&quot;); }).on(&quot;disconnect&quot;, (error) =&gt; { /** * Fired when a room disconnects * @event Client#roomDisconnect * @prop {Error?} error The error, if any * @prop {Number} id The ID of the room */ this._client.emit(&quot;roomDisconnect&quot;, error, room.id); for (var other of this) { if (other[1].ready) { return; } } this._client.ready = false; this._client.startTime = 0; /** * Fired when all rooms disconnect * @event Client#disconnect */ this._client.emit(&quot;disconnect&quot;); }); } } spawn(site) { var room = this.get(room); if (!room) { this.add(new Room(site, this._client)); this.connectQueue.push(site); } } createMessage(room, content) { return new Promise((resolve, reject) =&gt; { if (!(room || content)) reject(&quot;No room or content specified&quot;); room = this.find((r) =&gt; (r.name || r.id) == room); if (!room) reject(&quot;Inexistent room&quot;); room.createMessage(content); resolve(); }); } getMessages(room, limit = 50) { return new Promise((resolve, reject) =&gt; { if (!(room)) reject(&quot;No room specified&quot;); room = this.find((r) =&gt; (r.name || r.id) == room); if (!room) reject(&quot;Inexistent room&quot;); const messages = Array.from(room.messages); var logs = []; if (limit &lt;= messages.length) { return resolve(messages.slice(messages.length - limit, messages.length).map((message) =&gt; message[1]).concat(logs)); } limit -= messages.length; logs = messages.map((message) =&gt; message[1]).concat(logs); if (messages.length &lt; 100) { return resolve(logs); } reject(); }); } editStatus(status) { this.forEach((room) =&gt; { room.editStatus(status); }); } toJSON() { var base = {}; for (var key in this) { if (key in this &amp;&amp; !key.startsWith(&quot;_&quot;)) { if (typeof this[key].toJSON === &quot;function&quot;) { base[key] = this[key].toJSON(); } else { base[key] = this[key]; } } } return base; } } module.exports = RoomManager; × Search results Close "},"structures_Message.js.html":{"id":"structures_Message.js.html","title":"Source: structures/Message.js","body":" Gekkou Classes ClientMessageRoomUser Events Client#event:disconnectClient#event:loginClient#event:readyClient#event:roomDisconnectClient#event:roomReadyRoom#event:ready Source: structures/Message.js const Base = require(&quot;./Base&quot;); /** * Represents a message * @prop {Number} id The ID of the message * @prop {Room} room The room the message is in * @prop {Number} timestamp Timestamp of message creation * @prop {User} author The message author * @prop {String} content Message content * @prop {Command?} command The Command used in the Message, if any (CommandClient only) */ class Message extends Base { /** * @param {Object} data * @param {Client} client */ constructor(data, client) { super(data.id); this._client = client; this.update(data); } /** * @param {Object} data */ update(data) { this.room = data.room; this.timestamp = data.attrs.timeStamp; this.author = this.room.users.get(data.attrs.name); this.content = data.attrs.text; this.continued = data.attrs.continued; } /** * @param {String} content */ reply(content) { return this.room.createMessage.call(this.room, `${this.author.username}, ${content}`); } toJSON() { const base = super.toJSON(true); for (const key of [ &quot;author&quot;, &quot;content&quot;, &quot;timestamp&quot; ]) { base[key] = this[key] &amp;&amp; this[key].toJSON ? this[key].toJSON() : this[key]; } return base; } } module.exports = Message; × Search results Close "},"structures_Room.js.html":{"id":"structures_Room.js.html","title":"Source: structures/Room.js","body":" Gekkou Classes ClientMessageRoomUser Events Client#event:disconnectClient#event:loginClient#event:readyClient#event:roomDisconnectClient#event:roomReadyRoom#event:ready Source: structures/Room.js const Collection = require(&quot;../util/Collection&quot;); const Message = require(&quot;./Message&quot;); const Socket = require(&quot;socket.io-client&quot;); const User = require(&quot;./User&quot;); var EventEmitter; try { EventEmitter = require(&quot;eventemitter3&quot;); } catch (error) { EventEmitter = require(&quot;events&quot;).EventEmitter; } /** * Represents a room * @prop {String} id The ID of the room * @prop {String} site The site name of the room * @prop {Collection&lt;User&gt;} users A collection of users that are in the room * @prop {Number} userCount The number count of the users in the room * @prop {Number} latency The latency of the room */ class Room extends EventEmitter { /** * * @param {String} name The site name of the room */ constructor(name, client) { super(); this.id = name; this._client = client; this.users = new Collection(User); this.userCount = 0; this.messages = new Collection(Message, 1000); } get latency() { return this._lastPingSent &amp;&amp; this._lastPingReceived ? this._lastPingReceived - this._lastPingSent : Infinity; } /** * Tell the bot to start a connection to the room */ connect() { if (this.status === &quot;ready&quot;) { Promise.reject(&quot;Existing connection detected&quot;); } else { if (typeof this.id === &quot;number&quot;) { this.initializeSocket(); } else { this.getRoomInfo().then(() =&gt; this.initializeSocket()); } } } getRoomInfo() { return new Promise((resolve) =&gt; { this._client.request(&quot;GET&quot;, `http://${this.id}.wikia.com/api.php`, { action: &quot;query&quot;, meta: &quot;siteinfo&quot;, siprop: &quot;wikidesc&quot;, format: &quot;json&quot;, }).then((body) =&gt; { this._client.request(&quot;GET&quot;, `http://${this.id}.wikia.com/wikia.php`, { controller: &quot;Chat&quot;, format: &quot;json&quot;, }).then((chat) =&gt; { this.server = body.query.wikidesc.id; this.id = chat.roomId; this.key = chat.chatkey; resolve(); }); }); }); } initializeSocket() { this.socket = Socket.connect(this._client.options.forcehttp === true ? &quot;http://chat.wikia-services.com&quot; : &quot;https://chat.wikia-services.com&quot;, { query: { name: this._client.username, serverId: this.server, roomId: this.id, key: this.key } }); this.socket .on(&quot;connect&quot;, () =&gt; { this.ready = true; /** * Fired when the room turns ready * @event Room#ready */ super.emit(&quot;ready&quot;); this.status = &quot;ready&quot;; this.send({ attrs: { msgType: &quot;command&quot;, command: &quot;initquery&quot; } }); this._lastPingAck = true; }) .on(&quot;message&quot;, (fn) =&gt; { const event = fn.event; const data = typeof fn.data === &quot;string&quot; &amp;&amp; /^{|}$/.test(fn.data) ? JSON.parse(fn.data) : fn.data; switch (event) { case &quot;chat:add&quot;: data.room = this; this.emit(&quot;messageCreate&quot;, this.messages.add(new Message(data, this._client))); break; case &quot;join&quot;: if (data.attrs.name !== this._client.username) { data.id = data.attrs.name; data.room = this; if (!this.users.get(data.id)) { this.emit(&quot;userJoin&quot;, this.users.add(data, this._client)); ++this.userCount; ++this._client.userCount; } } break; case &quot;logout&quot;: data.id = data.attrs.name; data.room = this; if (this.users.get(data.id)) { this.emit(&quot;userPart&quot;, this.users.remove(data)); --this._client.userCount; --this.userCount; } break; case &quot;updateUser&quot;: data.id = data.attrs.name; data.room = this; this.emit(&quot;userUpdate&quot;, this.users.update(data, this._client)); break; case &quot;kick&quot;: data.id = data.attrs.kickedUserName; this.emit(&quot;userKick&quot;, this.users.remove(data), this.users.get(data.attrs.moderatorName)); --this._client.userCount; --this.userCount; break; case &quot;initial&quot;: { const users = data.collections.users.models; for (var user of users) { user.id = user.attrs.name; this.users.add(user, this._client); ++this.userCount; ++this._client.userCount; } const messages = data.collections.chats.models; for (var message of messages) { message.room = this; this.messages.add(new Message(message, this._client)); } } break; case &quot;openPrivateRoom&quot;: console.log(data); break; } }) .on(&quot;ping&quot;, () =&gt; { if (!this._lastPingAck) { return this.disconnect(new Error(&quot;Server didn't acknowledge previous ping, possible lost connection&quot;)); } this._lastPingAck = false; this._lastPingSent = new Date().getTime(); }) .on(&quot;pong&quot;, () =&gt; { this._lastPingAck = true; this._lastPingReceived = new Date().getTime(); }) .on(&quot;disconnect&quot;, () =&gt; { super.emit(&quot;disconnect&quot;); }); } /** * Tell the client to disconnect the room */ disconnect(error) { if (this.status === &quot;ready&quot;) { this.send({ attrs: { msgType: &quot;command&quot;, command: &quot;logout&quot;, } }); this.emit(&quot;debug&quot;, error | null); } else { Promise.reject(&quot;There's no connection to the room&quot;); } } /** * Creates a message to the room * @param {String} content */ createMessage(content) { this.send({ attrs: { msgType: &quot;chat&quot;, name: this._client.username, text: content, } }); } /** * Update the bot's status in the room * @param {String} status Sets the bot's status, either `here` or `away` */ editStatus(status) { this.send({ attrs: { msgType: &quot;command&quot;, command: &quot;setstatus&quot;, statusState: status } }); } getMessages(limit) { return this._client.rooms.getMessages.call(this._client.rooms, this.id, limit); } /** * Kick a member from the room * @param {String} member The name of the member */ kick(member) { if (/sysop|chatmoderator/.test(this.users.get(this._client.username).groups)) { if (!/sysop|chatmoderator/.test(this.users.get(member).groups)) { this.send({ attrs: { msgType: &quot;command&quot;, command: &quot;kick&quot;, userToKick: member } }); } else { Promise.reject(&quot;Client is lower or same in rights&quot;); } } else { Promise.reject(&quot;Missing permissions&quot;); } } /** * Ban an user in the room * @param {String} user The user to ban * @param {String} reason The reason to ban the user * @param {Number} time The length of the ban (in milliseconds; default to one day) */ ban(user, reason = &quot;Bad behavior&quot;, time = 86400) { this.send({ attrs: { msgType: &quot;command&quot;, command: &quot;ban&quot;, userToBan: user, reason, time } }); } /** * Send a 'message' event * @param {Object} attrs The attributes object * @returns {Promise&lt;String&gt;} */ send(attrs, ack) { if (typeof attrs !== &quot;object&quot;) return; return new Promise((resolve, reject) =&gt; { attrs = JSON.stringify(attrs); if (this.status === &quot;ready&quot;) { this.socket.send(attrs, ack); resolve(attrs); } else { reject(&quot;Room is not ready&quot;); } }); } emit(event) { this._client.emit.apply(this._client, arguments); if (event !== &quot;error&quot; || this.listeners(&quot;error&quot;).length &gt; 0) { super.emit.apply(this, arguments); } } } module.exports = Room; × Search results Close "},"structures_User.js.html":{"id":"structures_User.js.html","title":"Source: structures/User.js","body":" Gekkou Classes ClientMessageRoomUser Events Client#event:disconnectClient#event:loginClient#event:readyClient#event:roomDisconnectClient#event:roomReadyRoom#event:ready Source: structures/User.js const Base = require(&quot;./Base&quot;); const {NOCOOKIE_URL} = require(&quot;../rest/Endpoints&quot;); /** * Represents a user * @prop {String} username The user username * @prop {String} avatarURL the user avatar URL */ class User extends Base { constructor(data, client) { super(data.attrs.name); this._client = client; this.update(data); } update(data) { this.username = data.attrs.name; this.since = data.attrs.since[&quot;0&quot;]; this.status = { &quot;state&quot;: data.attrs.statusState, &quot;message&quot;: data.attrs.statusMessage }; this.avatar = data.attrs.avatarSrc.replace(/https?:\\/.+?\\/|\\/.+?$/g, &quot;&quot;); this.groups = data.attrs.groups; this.editCount = data.attrs.editCount; this.room = data.room; } get avatarURL() { return this.avatar ? `${NOCOOKIE_URL}/${this.avatar}/scale-to-width-down/${this._client.options.defaultImageSize}` : undefined; } toJSON() { const base = {}; for (const key of [ &quot;avatar&quot;, &quot;editCount&quot;, &quot;groups&quot;, &quot;since&quot;, &quot;status&quot;, &quot;username&quot; ]) { base[key] = this[key]; } return base; } } module.exports = User; × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Gekkou Classes ClientMessageRoomUser Events Client#event:disconnectClient#event:loginClient#event:readyClient#event:roomDisconnectClient#event:roomReadyRoom#event:ready Classes Classes Client Message Room User Events disconnect Fired when all rooms disconnect Source: rooming/RoomManager.js, line 60 login Fired when the user is logged Source: Client.js, line 109 ready Fired when all rooms turn ready Source: rooming/RoomManager.js, line 40 roomDisconnect Fired when a room disconnects Properties: Name Type Argument Description error Error &lt;nullable&gt; The error, if any id Number The ID of the room Source: rooming/RoomManager.js, line 46 roomReady Fired when a room turns ready Properties: Name Type Description id Number the ID of the room Source: rooming/RoomManager.js, line 24 ready Fired when the room turns ready Source: structures/Room.js, line 88 × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Gekkou Classes ClientMessageRoomUser Events Client#event:disconnectClient#event:loginClient#event:readyClient#event:roomDisconnectClient#event:roomReadyRoom#event:ready × Search results Close "},"Client.html":{"id":"Client.html","title":"Class: Client","body":" Gekkou Classes ClientMessageRoomUser Events Client#event:disconnectClient#event:loginClient#event:readyClient#event:roomDisconnectClient#event:roomReadyRoom#event:ready Class: Client Client Represents a Gekkou client new Client(username, password [, options]) Create a client Parameters: Name Type Argument Description username String Client username password String Client password options Object &lt;optional&gt; Gekkou options (optional) Properties Name Type Argument Default Description autoreconnect Boolean &lt;optional&gt; true Have Gekkou autoreconnect when connection is lost forcehttp Boolean &lt;optional&gt; false Disable HTTPS and force connecting to chat over HTTP. Only enable if you have problems connecting over HTTPS. defaultImageSize Number &lt;optional&gt; 150 The default size to return user avatars or anything else. Can be whatever you want. Properties: Name Type Description username String The client username password String The client password site String The client wiki domain startTime Number Timestamp of bot ready event uptime Number How long in milliseconds the client has been up for Source: Client.js, line 19 Methods connect(sites) Tell the client to connect all rooms.The arguments passed will be taken as sites to connect the bot Parameters: Name Type Argument Description sites String &lt;repeatable&gt; The site to connect Source: Client.js, line 67 Returns: Resolves when the client are connected Type Promise createMessage(room, content) Create a message Parameters: Name Type Description room String A room ID or name to send the message content String A content string Source: Client.js, line 136 editStatus(status) Update the bot's status in all rooms Parameters: Name Type Description status String Sets the bot's status, either here or away Source: Client.js, line 145 Events disconnect Fired when all rooms disconnect Source: rooming/RoomManager.js, line 60 login Fired when the user is logged Source: Client.js, line 109 ready Fired when all rooms turn ready Source: rooming/RoomManager.js, line 40 roomDisconnect Fired when a room disconnects Properties: Name Type Argument Description error Error &lt;nullable&gt; The error, if any id Number The ID of the room Source: rooming/RoomManager.js, line 46 roomReady Fired when a room turns ready Properties: Name Type Description id Number the ID of the room Source: rooming/RoomManager.js, line 24 × Search results Close "},"Message.html":{"id":"Message.html","title":"Class: Message","body":" Gekkou Classes ClientMessageRoomUser Events Client#event:disconnectClient#event:loginClient#event:readyClient#event:roomDisconnectClient#event:roomReadyRoom#event:ready Class: Message Message Represents a message new Message(data, client) Parameters: Name Type Description data Object client Client Properties: Name Type Argument Description id Number The ID of the message room Room The room the message is in timestamp Number Timestamp of message creation author User The message author content String Message content command Command &lt;nullable&gt; The Command used in the Message, if any (CommandClient only) Source: structures/Message.js, line 13 Methods reply(content) Parameters: Name Type Description content String Source: structures/Message.js, line 41 update(data) Parameters: Name Type Description data Object Source: structures/Message.js, line 29 × Search results Close "},"Room.html":{"id":"Room.html","title":"Class: Room","body":" Gekkou Classes ClientMessageRoomUser Events Client#event:disconnectClient#event:loginClient#event:readyClient#event:roomDisconnectClient#event:roomReadyRoom#event:ready Class: Room Room Represents a room new Room(name) Parameters: Name Type Description name String The site name of the room Properties: Name Type Description id String The ID of the room site String The site name of the room users Collection.&lt;User&gt; A collection of users that are in the room userCount Number The number count of the users in the room latency Number The latency of the room Source: structures/Room.js, line 22 Methods ban(user, reason, time) Ban an user in the room Parameters: Name Type Default Description user String The user to ban reason String Bad behavior The reason to ban the user time Number 86400 The length of the ban (in milliseconds; default to one day) Source: structures/Room.js, line 250 connect() Tell the bot to start a connection to the room Source: structures/Room.js, line 43 createMessage(content) Creates a message to the room Parameters: Name Type Description content String Source: structures/Room.js, line 197 disconnect() Tell the client to disconnect the room Source: structures/Room.js, line 180 editStatus(status) Update the bot's status in the room Parameters: Name Type Description status String Sets the bot's status, either here or away Source: structures/Room.js, line 211 kick(member) Kick a member from the room Parameters: Name Type Description member String The name of the member Source: structures/Room.js, line 227 send(attrs) Send a 'message' event Parameters: Name Type Description attrs Object The attributes object Source: structures/Room.js, line 266 Returns: Type Promise.&lt;String&gt; Events ready Fired when the room turns ready Source: structures/Room.js, line 88 × Search results Close "},"User.html":{"id":"User.html","title":"Class: User","body":" Gekkou Classes ClientMessageRoomUser Events Client#event:disconnectClient#event:loginClient#event:readyClient#event:roomDisconnectClient#event:roomReadyRoom#event:ready Class: User User Represents a user new User() Properties: Name Type Description username String The user username avatarURL String the user avatar URL Source: structures/User.js, line 10 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
